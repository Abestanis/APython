import java.nio.file.Files
import java.nio.file.Paths
import java.nio.file.StandardCopyOption

plugins {
    id 'com.android.application'
    id 'kotlin-android'
}

android {
    compileSdkVersion 29

    defaultConfig {
        applicationId "com.apython.python.pythonhost"
        minSdkVersion 16
        targetSdkVersion 29
        versionCode 1
        versionName "0.0.1"
        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
    }

    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        }
    }
    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_8
        targetCompatibility JavaVersion.VERSION_1_8
    }
    kotlinOptions {
        jvmTarget = '1.8'
    }
    externalNativeBuild {
        cmake {
            path file('src/main/jni/CMakeLists.txt')
            version "3.10.2+"
        }
    }
}

dependencies {
    implementation "org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version"
    implementation 'androidx.core:core-ktx:1.3.2'
    implementation 'androidx.appcompat:appcompat:1.2.0'
    implementation 'com.google.android.material:material:1.2.1'
    implementation 'androidx.constraintlayout:constraintlayout:2.0.4'
    implementation 'androidx.swiperefreshlayout:swiperefreshlayout:1.1.0'
    implementation 'org.apache.commons:commons-compress:1.20'
    testImplementation 'junit:junit:4.13.1'
    androidTestImplementation 'androidx.test.ext:junit:1.1.2'
    androidTestImplementation 'androidx.test.espresso:espresso-core:3.3.0'
}

def localProperties = new Properties()
localProperties.load(new FileInputStream(rootProject.file('local.properties')))
tasks.whenTaskAdded {
    task ->
        if (task.name in ['generateDebugResources', 'generateReleaseResources']) {
            task.finalizedBy updatePythonLibZips
        }
        if (task.name.startsWith('externalNativeBuild')) {
            task.finalizedBy {
                copyExecutable
            }
        }
}
File buildCacheDir = new File(System.getProperty("java.io.tmpdir"), "APythonBuildLibraryCache")

task copyExecutable(type: Copy, description: 'Copy the Python executable binaries.') {
    from 'build/intermediates/cmake/debug/obj' // TODO: Change for release builds
    include '*/python-pie'
    include '*/python'
    into 'src/main/assets'
}
task createDiffs(type: DiffMaker,
        description: 'Create the diffs for the Python versions and additional libraries') {
    versionsSourceDir = file('src/main/jni/DevLibs')
    patchOutputDir = file('src/main/jni/DevLibs/patches')
    cacheDir = buildCacheDir
    downloadUrl = 'https://www.python.org/ftp/python/%VERSION%/Python-%VERSION%.tgz'
    libConfigFile new File(file(localProperties['apython.libs.dir']), 'libraries.cfg')
}
task setupAdditionalLibrarySources(type: SetupAdditionalLibrarySources,
        description: 'Download and extract sources for all additional libraries') {
    libConfigFile new File(file(localProperties['apython.libs.dir']), 'libraries.cfg')
    cacheDir buildCacheDir
}
task updatePythonLibZips(type: UpdatePythonLibZips,
        description: 'Create a zip of the Python libraries and place it in the ' +
                'test assets folder so it can be used during testing.') {
    pythonSourceParentDir file('src/main/jni/DevLibs')
    destinationDir file('src/androidTest/assets/')
}
task SyncBuildSystem(type: Copy,
        description: 'Copy the neccesary files to sync with the APython Libs build system') {
    from('src/main/jni/DevLibs') {
        include '*/CMakeLists.txt'
        exclude 'PythonPatch/*'
        into 'buildFiles'
    }
    from('src/main/jni/DevLibs/PythonPatch') {
        into 'modules/PythonPatch'
    }
    from('src/main/jni/DevLibs/patches') {
        into 'patches'
    }
    into localProperties['apython.libs.dir']
    includeEmptyDirs = false
}

class Util {
    /**
     * Find and verify a git executable path.
     * @return A path to a valid git executable
     */
    static String[] getGitExecPath(Project project) {
        try {
            'git --version'.execute().waitFor()
            return ['git']
        } catch (IOException ignored) {}
        Properties properties = new Properties()
        File propertiesFile = project.rootProject.file('local.properties')
        try {
            properties.load(propertiesFile.newDataInputStream())
        } catch (FileNotFoundException ignored) {}
        String gitPath = properties.getProperty('git.path')
        if (gitPath == null) {
            throw new InvalidUserDataException('No Git executable found! Define the location with' +
                    ' git.path in ' + propertiesFile.absolutePath + '.')
        }
        try {
            (gitPath + ' --version').execute().waitFor()
            return [gitPath]
        } catch (IOException ignored) {
            thow new InvalidUserDataException('Git executable not found at the location specified' +
                    ' with git.path in ' + propertiesFile.absolutePath + '.')
        }
    }

    static String getGitBranch(String[] gitPath) {
        def execReturn
        def execState = ((String[]) (gitPath + 'status')).execute()
        if ((execReturn = execState.waitFor()) != 0) {
            throw new GradleException('git status failed with exit code ' + execReturn)
        }
        def gitStatusLines = execState.inputStream.readLines()
        if (gitStatusLines.size() < 1 || !gitStatusLines[0].startsWith('On branch ')) {
            println('Data returned by "git status":')
            for (def line in gitStatusLines) {println(line)}
            throw new GradleException('git status returned invalid data')
        }
        return gitStatusLines[0].substring(10).trim()
    }

    static File download(Project project, String url, File destDir) {
        download(project, url, destDir, null)
    }

    static File download(Project project, String url, File destDir, File cacheDir) {
        def urlSource = new URL(url)
        def segments = urlSource.getPath().split("/")
        def fileName = segments[segments.length - 1]
        if (url.contains('github.com') && !url.endsWith('.zip')) {
            if (!url.endsWith('/')) url += '/'
            url += 'archive/master.zip'
            urlSource = new URL(url)
            fileName += '.zip'
        }
        File dest = new File(destDir, fileName)
        println('Downloading source files from \'' + url + '\'...')
        if (cacheDir != null) {
            File cacheFile = new File(cacheDir, fileName)
            if (cacheFile.isFile()) {
                println('Using cached version from \'' + cacheFile.absolutePath + '\'...')
                if (dest.isFile()) {
                    dest.delete()
                } else if (dest.isDirectory()) {
                    dest.deleteDir()
                }
                def result = project.copy {
                    from cacheFile
                    into destDir
                }
                if (result.didWork) {
                    return dest
                } else {
                    project.getLogger().log(
                            LogLevel.WARN, 'Failed to copy cached version, downloading...')
                }
            }
        }
        for (int attempt = 1; attempt <= 3; attempt++) {
            try {
                urlSource.withInputStream { i ->
                    dest.withOutputStream {
                        it << i
                    }
                }
                break
            } catch (Exception error) {
                if (dest.exists()) {
                    dest.delete()
                }
                if (attempt == 3) {
                    throw new GradleException(
                            'Downloading source files from "' + url + '" failed.', error)
                } else {
                    project.getLogger().log(LogLevel.WARN, 'Download attempt ' + attempt +
                            ' from "' + url + '" failed. Retrying...')
                }
            }
        }
        return dest
    }

    static boolean copy(Project project, sourceTree, File dest, PatternFilterable filter) {
        def success = false
        if (filter != null) {
            sourceTree = sourceTree.matching(filter)
        }
        try {
            success = project.copy({
                from sourceTree
                into dest
            }).didWork
        } catch (GradleException e) {
            e.printStackTrace()
        } finally {
        }
        return success
    }

    static boolean extract(Project project, File src, File dest,
                           PatternFilterable filter, boolean deleteSrc, boolean removeFirstDir) {
        println('Extracting files...')
        if (dest.exists()) {
            dest.deleteDir()
        }
        def srcTree = null
        if (src.getName().endsWith('.zip')) {
            srcTree = project.zipTree(src)
        } else if (src.getName().contains('.tar') || src.getName().endsWith('.tgz')) {
            srcTree = project.tarTree(src)
        }
        if (srcTree == null) {
            throw new GradleException('Unsupportet archive format "' + src.getName() + '".')
        }
        def success = copy(project, srcTree, dest, removeFirstDir ? null : filter)
        if (deleteSrc) src.delete()
        if (success && removeFirstDir) {
            def children = dest.listFiles()
            if (children.size() != 1) {
                throw new GradleException('Extracted directory from archive ' + src.absolutePath +
                        ' does not contain just one directory.')
            }
            def childDir = children[0]
            if (!childDir.isDirectory()) {
                throw new GradleException('The extracted archive ' + src.absolutePath +
                        ' does not contain a directory at its top level.')
            }
            if (new File(childDir, childDir.getName()).exists()) {
                def oldChildDir = childDir
                childDir = new File(childDir.getParentFile(),
                        'TempMovingDir-ApythonProject-Py-Random')
                Files.move(Paths.get(oldChildDir.getPath()),
                        Paths.get(childDir.getPath()), StandardCopyOption.REPLACE_EXISTING)
            }
            success = copy(project, project.fileTree(childDir), childDir.getParentFile(), filter)
            childDir.deleteDir()
        }
        return success
    }

    static int execProcess(Appendable errorOutput, String[] command, String... arguments) {
        def execState = ((String[]) (command + arguments)).execute()
        execState.waitForProcessOutput(null, errorOutput)
        return execState.waitFor()
    }

    static def parseLibConfigFile(File libConfigFile) {
        HashMap<String, HashMap<String, String>> config = new HashMap<>()
        String currentSectionName = null
        HashMap<String, String> currentSection = null
        for (line in libConfigFile.readLines()) {
            line = line.trim()
            if (line.startsWith('[') && line.endsWith(']')) {
                if (currentSection != null) {
                    config.put(currentSectionName, currentSection)
                }
                currentSectionName = line.substring(1, line.length() - 1).trim()
                currentSection = new HashMap<>()
            } else if (!line.isEmpty()) {
                def parts = line.split('=', 2)
                if (parts.size() != 2) {
                    throw new GradleException('library config file at '
                            + libConfigFile.absolutePath + ' contains an invalid line:\n' + line)
                }
                currentSection.put(parts[0].trim(), parts[1].trim())
            }
        }
        if (currentSection != null) {
            config.put(currentSectionName, currentSection)
        }
        return config
    }

    static def formatDiffOutput(String output, String[] pathsToDelete) {
        def diffString = new StringBuilder()
        def pathsToDeleteFormat = "(\\Q" + pathsToDelete.join("\\E|\\Q") + "\\E)"
        def ignorePattern = /(index .*?\\.\\.|similarity index |rename from |rename to ).*/
        for (String line : output.split('\n')) {
            if (line ==~ ignorePattern) {
                continue
            }
            if (pathsToDelete.length > 0) {
                line = line.replaceAll(pathsToDeleteFormat, "")
            }
            if (line.startsWith('--- "') || line.startsWith('+++ "')) {
                line = line.replaceFirst("\"", "")
                int pos = line.lastIndexOf("\"")
                if (pos > -1) {
                    line = line.substring(0, pos) + line.substring(pos + 1)
                }
            }
            diffString.append(line).append('\n')
        }
        return diffString.toString()
    }
    
    static def filterFromLibConfig(Map<String, String> libConfig) {
        if (!libConfig.containsKey('extraction_filter')) {
            return null
        }
        def filter = new PatternSet()
        def includes = []
        for (String include : libConfig.get('extraction_filter').split(', ')) {
            includes.add(include)
            if (!(include ==~ /.*\.[^\/]+$/)) {
                includes.add(include + "/**")
            }
        }
        filter.setIncludes(includes)
        return filter
    }
}


class UpdatePythonLibZips extends DefaultTask {
    @InputDirectory
    File pythonSourceParentDir
    @OutputDirectory
    File destinationDir

    @TaskAction
    void execute(IncrementalTaskInputs inputs) {
        def pythonSourceDirs
        if (inputs.incremental) {
            Set<File> pythonSourceDirSet = new HashSet<>()
            def checkChanged = { change ->
                def relativePath = pythonSourceParentDir.toPath().relativize(change.file.toPath())
                def directory = pythonSourceParentDir.toPath()
                        .resolve(relativePath.subpath(0, 1)).toFile()
                if (directory.isDirectory() && directory.name.matches("Python\\d\\.\\d\\.\\d\$")) {
                    if (relativePath.subpath(1, relativePath.nameCount)
                            .startsWith(Paths.get('source', 'Lib'))) {
                        pythonSourceDirSet.add(directory)
                    }
                }
            }
            inputs.outOfDate checkChanged
            inputs.removed checkChanged
            pythonSourceDirs = pythonSourceDirSet.toArray(new File[0])
        } else {
            pythonSourceDirs = pythonSourceParentDir.listFiles(new FileFilter() {
                @Override
                boolean accept(File pathname) {
                    if (!pathname.isDirectory()
                            || !pathname.getName().matches("Python\\d\\.\\d\\.\\d\$")) {
                        return false
                    }
                    def versionParts = pathname.getName().substring("Python".length()).split("\\.")
                    return !(new File(destinationDir,
                            "lib" + versionParts[0] + "_" + versionParts[1] + ".zip").exists())
                }
            })
        }
        for (File pythonSource: pythonSourceDirs) {
            def version = pythonSource.getName().substring(6)
            def libDir = pythonSource.toPath().resolve('source').resolve('Lib').toFile()
            if (!libDir.isDirectory()) {
                getLogger().log(LogLevel.WARN,
                        'Could not find the Python std modules at ' + libDir.absolutePath)
                continue
            }
            println("Creating std module zip for Python $version...")
            def versionParts = version.split('\\.')
            def libName = 'lib' + versionParts[0] + '_' + versionParts[1]
            def zipTask = project.tasks.create(name: "updatePython$libName", type: Zip) {
                from libDir
                destinationDir this.destinationDir
                baseName libName
                extension 'zip'
            }
            zipTask.copy()
            if (!zipTask.didWork) {
                setDidWork(false)
                getLogger().log(LogLevel.ERROR, "Failed to create Zip for Python version $version.")
                return
            }
        }
    }
}

class SetupAdditionalLibrarySources extends DefaultTask {
    @InputFile
    File libConfigFile

    File cacheDir
    File librariesDir = project.file('src/main/jni/DevLibs')

    @TaskAction
    def run() {
        String[] gitExecPath = Util.getGitExecPath(project)
        def libConfig = Util.parseLibConfigFile(libConfigFile)
        int execReturn
        def errorStringBuffer = new StringWriter()
        gitExecPath += ['-C', librariesDir.absolutePath]
        if ((execReturn = Util.execProcess(errorStringBuffer, gitExecPath, 'stash')) != 0) {
            throw new GradleException('git stash failed with exit code ' + execReturn +
                    "\nOutput: " + errorStringBuffer.toString())
        }
        try {
            // Check that we are clean
            def currBranch = Util.getGitBranch(gitExecPath)
            println('Current branch: ' + currBranch)
            if (currBranch == 'updateLibraries') {
                throw new GradleException('Invalid state: Currently on branch ' + currBranch +
                        ". If this is a branch generated by a prevoius execution of this script, " +
                        "switch to another branch and execute this script again.")
            }
            def execState = ((String[]) (gitExecPath + 'status')).execute()
            if ((execReturn = execState.waitFor()) != 0) {
                throw new GradleException('git status failed with exit code ' + execReturn)
            }
            def gitStatusLines = execState.inputStream.readLines()
            if (gitStatusLines.size() < 1 || !gitStatusLines[0].startsWith('On branch ')) {
                println('Data returned by "git status":')
                for (def line in gitStatusLines) {println(line)}
                throw new GradleException('git status returned invalid data')
            }
            for (line in gitStatusLines) {
                if (line.startsWith('Changes not staged for commit:')) {
                    throw new GradleException('There are still changes in the working tree ' +
                            'after git stash')
                }
            }
            // Check if updateLibraries exists
            execState = ((String[]) (
                    gitExecPath + ['branch', '--list', 'updateLibraries'])).execute()
            if ((execReturn = execState.waitFor()) != 0) {
                throw new GradleException('git branch --list failed with exit code ' + execReturn)
            }
            def branchExists = false
            for (line in execState.inputStream.readLines()) {
                if (!line.trim().isEmpty()) {
                    branchExists = true
                    break
                }
            }
            if (branchExists) {
                execReturn = Util.execProcess(null, gitExecPath, 'checkout', 'updateLibraries')
            } else {
                execReturn = Util.execProcess(null,
                        gitExecPath, 'checkout', '-b', 'updateLibraries')
            }
            if (execReturn != 0) {
                throw new GradleException('git checkout failed with exit code ' + execReturn)
            }
            assert Util.getGitBranch(gitExecPath) == 'updateLibraries'
            try {
                errorStringBuffer = new StringWriter()
                if ((execReturn = Util.execProcess(errorStringBuffer,
                        gitExecPath, 'reset', '--hard', currBranch)) != 0) {
                    throw new GradleException('git reset failed with exit code ' + execReturn
                            + '\nOutput: ' + errorStringBuffer.toString())
                }
                def updatedLibs = updateLibraries(libConfig)
                println('Committing changes...')
                String message = 'Update libraries\n\n'
                for (lib in updatedLibs) {
                    message += lib + ' from ' + libConfig.get(lib).get('url') + '\n'
                }
                errorStringBuffer = new StringWriter()
                if ((execReturn = Util.execProcess(errorStringBuffer,
                        gitExecPath, 'add', '-A')) != 0) {
                    throw new GradleException('git add failed with exit code ' + execReturn +
                            '\nOutput: ' + errorStringBuffer.toString())
                }
                errorStringBuffer = new StringWriter()
                if ((execReturn = Util.execProcess(errorStringBuffer,
                        gitExecPath,'commit', '-m', message)) != 0) {
                    throw new GradleException('git commit failed with exit code ' + execReturn +
                            '\nOutput: ' + errorStringBuffer.toString())
                }
            } finally {
                // Switch back to the previous branch
                if (Util.execProcess(null, gitExecPath, 'checkout', currBranch) != 0) {
                    (gitExecPath + 'stash').execute().waitForProcessOutput(null, null)
                    errorStringBuffer = new StringWriter()
                    if ((execReturn = Util.execProcess(errorStringBuffer,
                            gitExecPath, 'checkout', currBranch)) != 0) {
                        getLogger().log(LogLevel.ERROR, "!!!\ngit checkout " + currBranch +
                                " failed with exit code " + execReturn + "! Try to run it " +
                                "manually and the git stash apply to fix your branch state.\n!!!" +
                                "\nOutput: " + errorStringBuffer.toString())
                    }
                }
            }
        } finally {
            // Cleanup
            errorStringBuffer = new StringWriter()
            if ((execReturn = Util.execProcess(errorStringBuffer,
                    gitExecPath, 'stash', 'pop')) != 0) {
                getLogger().log(LogLevel.ERROR, "!!!\ngit stash pop failed with exit code " +
                        execReturn + "! Try to run it manually to see what is wrong.\n!!!\nOutput: "
                        + errorStringBuffer.toString())
            }
        }
        // Display message
        println('############################################\n' +
                '# !Additional libraries have been updated! #\n' +
                '# Merge from the "updateLibraries" branch. #\n' +
                '############################################')
    }

    ArrayList<String> updateLibraries(HashMap<String, HashMap<String, String>> libConfig) {
        // Check version
        def libsToUpdate = new ArrayList<String>()
        for (libData in libConfig.entrySet()) {
            def libName = libData.key
            if (!libData.value.containsKey('url')) {
                getLogger().log(LogLevel.ERROR,
                        "Section " + libName + ' misses entry "url". Skipping it.')
                continue
            }
            if (project.file(getLibDirectory(libName) + '/.git').exists()) {
                getLogger().log(LogLevel.DEBUG,
                        "Skipping " + libName + ' because it is included as a git repository.')
                continue
            }
            libsToUpdate.add(libName)
        }
        for (libName in libsToUpdate) {
            println('Updating ' + libName)
            def libData = libConfig.get(libName)
            // Download
            def url = libData.get('url')
            File archive = Util.download(project, url, this.temporaryDir, this.cacheDir)
            // extract and overwrite
            File sourceDir = project.file(getLibDirectory(libName) + '/source')
            if (!Util.extract(project, archive, sourceDir, null, true, true)) {
                getLogger().log(LogLevel.ERROR, 'Failed to extract archive ' + archive.absolutePath)
                currentLibData.remove(libName)
            }
        }
        return libsToUpdate
    }

    String getLibDirectory(String libName) {
        return librariesDir.absolutePath + '/' + libName.capitalize()
    }
}


class DiffMaker extends DefaultTask {
    @InputDirectory
    File versionsSourceDir

    @InputFile
    File libConfigFile

    File cacheDir = new File(System.getProperty("java.io.tmpdir"), "APythonBuildLibraryCache")

    @Input
    String downloadUrl

    @OutputDirectory
    File patchOutputDir

    @TaskAction
    def main() {
        String[] gitExecPath = Util.getGitExecPath(project)
        def libConfig = Util.parseLibConfigFile(libConfigFile)
        // Add the Python versions
        def sourceDirs = versionsSourceDir.listFiles()
        def pythonIncludes = ['Include', 'Lib', 'Modules', 'Objects', 'Parser', 'Python', 'LICENSE',
                              'README']
        def pyFileTypeFilter = ['*.c', '*.h', '*.py', '*.pyc', '*.inc', '*.txt', '*.gif', '*.png',
                                '*.def']
        for (File sourceDir : sourceDirs) {
            if (!sourceDir.name.matches("Python\\d\\.\\d.*")) continue
            def version = sourceDir.name.substring(6)
            HashMap<String, String> data = new HashMap<>()
            data.put('url', downloadUrl.replaceAll("%VERSION%", version))
            data.put('extraction_filter', pythonIncludes.join(", "))
            data.put('file_type_filter', pyFileTypeFilter.join(", "))
            libConfig.put(sourceDir.name, data)
        }
        // Cleaning output dir
        def oldPatchFiles = patchOutputDir.listFiles(new FilenameFilter() {
            @Override
            boolean accept(File dir, String name) {
                return name.endsWith('.patch')
            }
        })
        for (def patchFile : oldPatchFiles) {
            patchFile.delete()
        }
        for (libData in libConfig.entrySet()) {
            def libName = libData.key
            if (!libData.value.containsKey('url')) {
                getLogger().log(LogLevel.ERROR,
                        "Section " + libName + ' misses entry "url". Skipping it.')
                continue
            }
//            if (libName == 'sdl2X11Emulation') continue // TODO: Test removal of this
            def url = libData.value.get('url')
            def sourceDir = null
            for (File dir : sourceDirs) {
                if (libName.equalsIgnoreCase(dir.name)) {
                    sourceDir = dir
                }
            }
            if (sourceDir == null) {
                throw new GradleException('Failed to find source dir of ' + libName
                        + ' in ' + versionsSourceDir.absolutePath)
            }
            def archiveFile = Util.download(project, url, this.temporaryDir, this.cacheDir)

            def filter = Util.filterFromLibConfig(libData.value)
            def extractDir = new File(this.temporaryDir, libName + '.orig')
            if (!Util.extract(project, archiveFile, extractDir, filter, true, true)) {
                throw new GradleException('Failed to extract ' + archiveFile.getAbsolutePath() + '.')
            }

            println("Copying sources of " + libName + "...")
            def modifiedSourcesDir = new File(sourceDir, 'source')
            sourceDir = new File(this.temporaryDir, sourceDir.name + '.new')
            if (!Util.copy(project, project.fileTree(modifiedSourcesDir), sourceDir, filter)) {
                throw new GradleException('Failed to copy '
                        + modifiedSourcesDir.getAbsolutePath() + '.')
            }

            println("Creating patch for " + libName + "...")
            patchOutputDir.mkdirs()
            def patchFile = new File(patchOutputDir, libName + ".patch")
            if (patchFile.exists()) patchFile.delete()
            def gitDiffProcess = new ProcessBuilder(gitExecPath + [
                    "--no-pager", "diff", "--no-index", "--no-prefix", "--diff-filter=RMA",
                    extractDir.name, sourceDir.name]).directory(sourceDir.parentFile).start()
            StringBuilder output = new StringBuilder()
            StringBuilder err = new StringBuilder()
            gitDiffProcess.waitForProcessOutput(output, err)
            if (err.contains("error: ")) {
                getLogger().log(LogLevel.ERROR, err.toString())
            } else {
                println(err)
            }
            String[] pathsToDelete = [
                    extractDir.absolutePath.replaceAll("\\\\", "\\\\\\\\"),
                    sourceDir.absolutePath.replaceAll("\\\\", "\\\\\\\\")
            ]
            println("Formatting diff...")
            def diffString = Util.formatDiffOutput(output.toString(), pathsToDelete)
            if (diffString.isEmpty()) {
                throw new GradleException('Failed to create patch for ' + libName +
                        ' (empty diff file).')
            }
            if (diffString == "\n") {
                println('Skipping empty diff.')
                continue
            }
            try {
                patchFile.write diffString
            } catch (IOException e) {
                println('Failed to save diff to "' + patchFile.absolutePath + '": ' + e.message)
                if (patchFile.exists()) patchFile.delete()
                throw e
            } finally {
                extractDir.deleteDir()
                sourceDir.deleteDir()
            }
            println('Sucessfully created diff at "' + patchFile.absolutePath + '".')
        }
    }
}
